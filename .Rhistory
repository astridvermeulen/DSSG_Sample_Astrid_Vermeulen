#If you finish outside of top 60, 0 points
#Can be altered to be more forgiving
basetable$points <- ifelse(basetable$Pos == 1, 10,
ifelse(basetable$Pos == 2, 9,
ifelse(basetable$Pos == 3, 8,
ifelse(basetable$Pos == 4, 7,
ifelse(basetable$Pos == 5, 6,
ifelse(basetable$Pos == 6, 5,
ifelse(basetable$Pos == 7, 4,
ifelse(basetable$Pos == 8, 3,
ifelse(basetable$Pos == 9, 2,
ifelse(basetable$Pos >= 10 && basetable$Pos <= 60, 1, 0)
)
))))))))
#Define that a driver has a specialty in a specific category if he has a score in that category above 75
#Exact cutoff also up for discussion, mcategories have a range between 50 and 85
#https://web.cyanide-studio.com/games/cycling/2021/pcm/guide/basics-specialisations/
basetable$flat_driver <- ifelse(basetable$FLAT >= 75,1,0)
basetable$mountain_driver <- ifelse(basetable$MOUNTAIN >= 75,1,0)
basetable$downhill_driver <- ifelse(basetable$DOWNHILL >= 75,1,0)
basetable$cobbles_driver <- ifelse(basetable$COBBLES >= 75,1,0)
basetable$tt_driver <- ifelse(basetable$TT >= 75,1,0)
basetable$prologue_driver <- ifelse(basetable$PROLOGUE >= 75,1,0)
basetable$sprint_driver <- ifelse(basetable$SPRINT >= 75,1,0)
basetable$acceleration_driver <- ifelse(basetable$ACCELERATION >= 75,1,0)
basetable$resistance_driver <- ifelse(basetable$RESISTANCE >= 75,1,0)
basetable$endurance_driver <- ifelse(basetable$ENDURANCE >= 75,1,0)
basetable$recup_driver <- ifelse(basetable$RECUP >= 75,1,0)
basetable$hill_driver <- ifelse(basetable$HILL >= 75,1,0)
basetable$attack_driver <- ifelse(basetable$ATTACK >= 75,1,0)
#Compute team scores on different aspects per race (quantifying team selection)
#Like this we get per row the specifics of a team, per race, per year
team_scores_per_race <-basetable %>%
group_by(Year, Race_ID, Team.x) %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
hist(team_scores_per_race$team_points)
team_scores_per_race %>%
glimpse()
#success is defined as when the team scores at least 10 points
team_scores_per_race$success <- ifelse(team_scores_per_race$team_points >= 10, 1, 0)
team_scores_per_race$success <- as.factor(team_scores_per_race$success)
#drop columns that are not of any use
drop <- c("Team.x", "Year", "team_points", "Race_ID")
team_scores_per_race = team_scores_per_race[,!(names(team_scores_per_race) %in% drop)]
# Inspect class imbalance
table(team_scores_per_race$success)
# create indicators randomize order of indicators
allind <- sample(x = 1:nrow(team_scores_per_race), size = nrow(team_scores_per_race))
# split in two equal parts
trainind <- allind[1:round(length(allind) * 0.5)]
testind <- allind[(round(length(allind) * (0.5)) + 1):length(allind)]
# actual subsetting
train <- team_scores_per_race[trainind, ]
test <- team_scores_per_race[testind, ]
# Inspect class imbalance
table(train$success)
##OVERSAMPLING##
# Get indices of each group
success <- which(train$success == "1")
fail <- which(train$success == "0")
# See how many instances we would want to have equal number
# as majority_class
n_desired <- length(fail)
resampled_success <- sample(x = success, size = n_desired,
replace = TRUE)
print(resampled_success)
##OVERSAMPLING##
# Get indices of each group
success <- which(train$success == "1")
fail <- which(train$success == "0")
# See how many instances we would want to have equal number
# as majority_class
n_desired <- length(fail)
resampled_success <- sample(x = success, size = n_desired,
replace = TRUE)
print(resampled_success)
##OVERSAMPLING##
# Get indices of each group
success <- which(train$success == "1")
fail <- which(train$success == "0")
# See how many instances we would want to have equal number
# as majority_class
n_desired <- length(fail)
resampled_success <- sample(x = success, size = n_desired,
replace = TRUE)
print(resampled_success)
# Combine into one large data set
train <- train[c(resampled_success, fail),]
table(train$success)
#Model building:
p_load(h2o)
h2o.init(max_mem_size = "7G")
train_h2o<-as.h2o(train)
test_h2o<-as.h2o(test)
y <- "success"
x <- setdiff(names(train_h2o), y)
#xgboost
# my_xgb <- h2o.xgboost(x = x,
#                            y = y,
#                            training_frame = train_h2o,
#                            validation_frame = test_h2o,
#                            booster = "dart",
#                            normalize_type = "tree",
#                            nfolds = 5,
#                            #fold_column = "group",
#                            keep_cross_validation_predictions = TRUE,
#                            seed = 5)
#naive bayes
my_nb <- h2o.naiveBayes(x = x,
y = y,
training_frame = train_h2o,
laplace = 0,
nfolds = 5,
#fold_column = "group",
keep_cross_validation_predictions = TRUE,
seed = 5)
# Train & Cross-validate a RF (REACHES CAPACITY EVERY TIME)
my_rf <- h2o.randomForest(x = x,
y = y,
training_frame = train_h2o,
nfolds = 5,
#fold_column = "group",
keep_cross_validation_predictions = TRUE,
seed = 5)
# Train & Cross-validate a LR
my_lr <- h2o.glm(x = x,
y = y,
training_frame = train_h2o,
family = c("binomial"),
nfolds = 5,
#fold_column = "group",
keep_cross_validation_predictions = TRUE,
seed = 5)
# Train a stacked ensemble using the models above
ensemble <- h2o.stackedEnsemble(x = x,
y = y,
metalearner_algorithm="AUTO",
training_frame = train_h2o,
base_models = list(#my_xgb,
my_nb, my_rf, my_lr))
# Eval ensemble performance on a test set
perf <- h2o.performance(ensemble, newdata = test_h2o)
# Compare to base learner performance on the test set
#perf_gbm_test <- h2o.performance(my_xgb, newdata = test_h2o)
perf_nb_test <- h2o.performance(my_nb, newdata = test_h2o)
perf_lr_test <- h2o.performance(my_lr, newdata = test_h2o)
perf_rf_test <- h2o.performance(my_rf, newdata = test_h2o)
baselearner_best_auc_test <- max(#h2o.auc(perf_gbm_test),
h2o.auc(perf_nb_test), h2o.auc(perf_lr_test), h2o.auc(perf_rf_test))
ensemble_auc_test <- h2o.auc(perf)
print(sprintf("Best Base-learner Test AUC:  %s", baselearner_best_auc_test))
print(sprintf("Ensemble Test AUC:  %s", ensemble_auc_test))
# predict
preds <- h2o.predict(ensemble, test_h2o)
mean(preds)
preds <- preds[,3]
preds = as.data.frame(preds)
colnames(preds) = c("prob_success")
preds <- cbind(preds)
preds[,1]
# Select the available team members of a given team in a given year
# Don't take them from first_cycling data
team_all <- basetable %>% filter((Team.x == 'Etixx - Quick Step') & (Year == 2016)) %>% distinct(Rider,.keep_all = T) %>% select(Rider,Team.x)
team_size <- nrow(team_all)
# create random vector
team_selection <- sample(c(0,1), replace=TRUE, size=2)
# create random vector
team_selection <- sample(c(0,1), replace=TRUE, size=team_size)
team_selection == 1
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection == 1,]
team_selection_name <- team_all[team_selection == 1,'Rider']
team_selection <- basetable %>% distinct(Rider ,.keep_all = T) %>% filter(Rider %in% team_selection_name)
View(team_selection)
#Compute team scores for the given team selection
# Will serve as input to the ensemble
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
summarize_function(team_selection)
summarize_function(team)
View(team)
summarize_function(team_selection)
View(basetable)
View(team_all)
# Select the available team members of a given team in a given year
# Don't take them from first_cycling data, as there are riders in there who don't appear in pro_cycling_data
team_all <- basetable %>% filter((Team.x == 'Etixx - Quick Step') & (Year == 2016)) %>% distinct(Rider,.keep_all = T) %>% select(Rider,Team.x)
team_all
# create random vector
team_selection_binary <- sample(c(0,1), replace=TRUE, size=nrow(team_all))
# create random vector
set.seed(123)
team_selection_binary <- sample(c(0,1), replace=TRUE, size=nrow(team_all))
team_selection == 1
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection == 1,]
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection_binary == 1,]
# create random vector
set.seed(123)
team_selection_binary <- sample(c(0,1), replace=TRUE, size=nrow(team_all))
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection_binary == 1,]
team_all %>% slice(team_selection_binary)
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection_binary == 1,]
team_all[team_selection_binary == 1,'Rider']
# Select rider names
team_selection_name <- team_all[team_selection_binary == 1,'Rider']
# Filter basetable on distinct names and get names from team selection. Filtering on distinct names first is necessary, otherwise you get the same riders multiple times. Not what we want.
team_selection <- basetable %>% distinct(Rider ,.keep_all = T) %>% filter(Rider %in% team_selection_name)
#Compute team scores for the given team selection
# Will serve as input to the ensemble
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
View(team)
# Select rider names
team_selection_name <- team_all[team_selection_binary == 1,'Rider']
# Filter basetable on distinct names and get names from team selection. Filtering on distinct names first is necessary, otherwise you get the same riders multiple times. Not what we want.
team_selection <- basetable %>% distinct(Rider ,.keep_all = T) %>% filter(Rider %in% team_selection_name)
#Compute team scores for the given team selection
# Will serve as input to the ensemble
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
View(team)
#Compute team scores for the given team selection
# Will serve as input to the ensemble
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
team
# Select the available team members of a given team in a given year
# Don't take them from first_cycling data, as there are riders in there who don't appear in pro_cycling_data
team_all <- basetable %>% filter((Team.x == 'Etixx - Quick Step') & (Year == 2016)) %>% distinct(Rider,.keep_all = T) %>% select(Rider,Team.x)
team_all
team_size <- nrow(team_all)
# create random vector
set.seed(123)
team_selection_binary <- sample(c(0,1), replace=TRUE, size=nrow(team_all))
# show selected riders
# opletten met dit, doet raar als je boolean vector meegeeft die korter is dan lengte van dataframe
team_all[team_selection_binary == 1,]
# Select rider names
team_selection_name <- team_all[team_selection_binary == 1,'Rider']
# Filter basetable on distinct names and get names from team selection. Filtering on distinct names first is necessary, otherwise you get the same riders multiple times. Not what we want.
team_selection <- basetable %>% distinct(Rider ,.keep_all = T) %>% filter(Rider %in% team_selection_name)
#Compute team scores for the given team selection
# Will serve as input to the ensemble
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
team
View(team_selection)
get_team_scores(team_selection_binary)
# Make function of previous chunks
# outputs a dataframe with the team scores
get_team_scores <- function(team_selection_binary){
team_selection_name <- team_all[team_selection_binary == 1,'Rider']
team_selection <- basetable %>% distinct(Rider ,.keep_all = T) %>% filter(Rider %in% team_selection_name)
team <- team_selection %>%
summarise(team_points = sum(points), team_popularity = sum(Popularity), team_potential = sum(Potential),
team_score_flat = sum(FLAT), team_score_mountain = sum(MOUNTAIN), team_score_downhill = sum(DOWNHILL),
team_score_cobbles = sum(COBBLES), team_score_tt = sum(TT), team_score_prologue = sum(PROLOGUE),
team_score_sprint = sum(SPRINT), team_score_acceleration = sum(ACCELERATION), team_score_endurance = sum(ENDURANCE),
team_score_resistance = sum(RESISTANCE), team_score_recup = sum(RECUP), team_score_hill = sum(HILL),
team_score_attack = sum(ATTACK),
avg_team_size = mean(Size), avg_team_weight = mean(Weight),
nr_drivers = n_distinct(Rider),
nr_flat_drivers = sum(flat_driver), nr_mountain_drivers = sum(mountain_driver), nr_downhill_drivers = sum(downhill_driver),
nr_cobbles_drivers = sum(cobbles_driver), nr_tt_drivers = sum(tt_driver), nr_prologue_drivers = sum(prologue_driver),
nr_sprint_drivers = sum(sprint_driver), nr_acceleration_drivers = sum(acceleration_driver), nr_resistance_drivers =
sum(resistance_driver), nr_endurance_drivers = sum(endurance_driver), nr_recup_drivers = sum(recup_driver),
nr_hill_drivers = sum(hill_driver), nr_attack_drivers = sum(attack_driver), avg_age_drivers = mean(age))
#drop columns that are not of any use
drop <- c("team_points")
team = team[,!(names(team) %in% drop)]
return(team)
}
get_team_scores(team_selection_binary)
team <- get_team_scores(team_selection_binary)
team
input <-as.h2o(team)
# predict
preds <- h2o.predict(ensemble, input)
mean(preds)
preds <- preds[,3]
preds = as.data.frame(preds)
colnames(preds) = c("prob_success")
preds <- cbind(preds)
preds[,1]
View(preds)
preds <- h2o.predict(ensemble, input)
View(preds)
mean(preds)
mean(preds)
preds[,3]
class(team)
preds <- preds[,3]
preds = as.data.frame(preds)
mean(preds)
preds = as.data.frame(preds)
View(preds)
colnames(preds) = c("prob_success")
preds[,1]
preds <- h2o.predict(ensemble, input)
preds = as.data.frame(preds)
View(preds)
preds[,3]
preds <- unlist(preds[,3])
# predict
preds <- h2o.predict(ensemble, test_h2o)
mean(preds)
preds <- preds[,3]
preds = as.data.frame(preds)
colnames(preds) = c("prob_success")
preds <- cbind(preds)
preds[,1]
# predict
preds <- h2o.predict(ensemble, input)
mean(preds)
preds <- preds[,3]
preds = as.data.frame(preds)
colnames(preds) = c("prob_success")
preds <- cbind(preds)
preds[,1]
preds <- h2o.predict(ensemble, input)
summary(preds)
preds <- as.data.frame(preds)
View(preds)
preds <- h2o.predict(ensemble, test_h2o)
preds <- as.data.frame(preds)
preds <- unlist(preds[,3])
preds <- h2o.predict(ensemble, test_h2o)
preds <- as.data.frame(preds)
View(preds)
# predict
preds <- h2o.predict(ensemble, input)
preds <- as.data.frame(preds)
preds <- unlist(preds[,3])
class(preds)
preds <- h2o.predict(ensemble, input)
preds <- as.data.frame(preds)
View(preds)
# Make evaluate function
evaluate <- function (x) {
input <- get_team_scores(x) # from driver selection, create teamscores df
input <- as.h2o(input) # convert df to h2o object
# predict
preds <- h2o.predict(ensemble, input) # predict prob of succes
preds <- as.data.frame(preds)
preds <- unlist(preds[,3]) # third column = prob(1) = prob(success)
obj <- preds
available_positions = sum(x) # constraint on positions
if(available_positions > 6) {
return(0) # If you violate the constraint = return a very low number
} else {
return (obj) # Maximization by default
}
}
#Model GA
result <- ga(type = "binary",
fitness = evaluate,
popSize = 10,
maxiter = 4,
pmutation = 0.01,
monitor = FALSE,
nBits = 18) # size of available riders
summary(result)
# Get selected drivers
summary(result)$solution
# Get selected drivers
rider_selection <- summary(result)$solution %>% as.numeric()
team_all[rider_selection ==1,]
# Make evaluate function
evaluate <- function (x) {
input <- get_team_scores(x) # from driver selection, create teamscores df
input <- as.h2o(input) # convert df to h2o object
# predict
preds <- h2o.predict(ensemble, input) # predict prob of succes
preds <- as.data.frame(preds)
preds <- unlist(preds[,3]) # third column = prob(1) = prob(success)
obj <- preds
available_positions = sum(x) # constraint on positions
if(available_positions > 6) {
return(0) # If you violate the constraint = return a very low number
} else {
return (obj) # Maximization by default
}
}
#Model GA
result <- ga(type = "binary",
fitness = evaluate,
popSize = 2,
maxiter = 4,
pmutation = 0.01,
monitor = FALSE,
nBits = 18) # size of available riders
summary(result)
# Make evaluate function
evaluate <- function (x) {
input <- get_team_scores(x) # from driver selection, create teamscores df
input <- as.h2o(input) # convert df to h2o object
# predict
preds <- h2o.predict(ensemble, input) # predict prob of succes
preds <- as.data.frame(preds)
preds <- unlist(preds[,3]) # third column = prob(1) = prob(success)
obj <- preds
available_positions = sum(x) # constraint on positions
if(available_positions > 6) {
return(0) # If you violate the constraint = return a very low number
} else {
return (obj) # Maximization by default
}
}
#Model GA
result <- ga(type = "binary",
fitness = evaluate,
popSize = 150,
maxiter = 100,
pmutation = 0.01,
monitor = FALSE,
nBits = 18) # size of available riders
